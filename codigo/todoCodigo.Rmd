---
title: "Todo de `R`, `Python` y `Octave`"
author: "María Santos"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment= NA)
```


- Los parámetros que se muestran igualados a un valor, están igualados a su valor por defecto.
- Si aparece `-` lo que indica es que no se ha visto función que lleve a cabo lo indicado en la descripción
- Si aparece `(*)` lo que indica es que el bloque de código se muestra al final del Tema correspondiente

## Tema 0

Descripción | `R` | `Python` | `Octave` | 
----------------- | ------------------- | ----------------- | ------------------- |



## Tema 1

Descripción | `R` | `Python` | `Octave` | 
----------------- | ------------------- | ----------------- | ------------------- |

## Tema 2

Descripción | `R` | `Python` | `Octave` | 
----------------- | ------------------- | ----------------- | ------------------- |
Resolver sistema compatible determinado | `solve(A,b)` | `numpy.linalg.solve(A,b)` | `linsolve(A,b)` |
Resolver sistema compatible | `Solve(A,b,fractions = F)` de la librería `matlib` | `linsolve()` de la librería `sympy`| `-` |
Calcular rango de una matriz | `qr(A)$rank`; `R()` de la librería `matlib` | `np.linalg.matrix_rank()` | `rank()` |
Mostrar ecuaciones de un sistema | `showEqn(A,b)` | `-` | `-` |
Comprobar si el sistema es compatible | `all.equal(R(A),R(AB))` | `-` | `-` |
Representar gráficamente ecuaciones de un sistema con 2 incógnitas | `plotEqn(A,b)` de la librería `matlib` | `matplotlib.pyplot.plot(x,y1,...,x,yn)` | `plot(x,y1,...,x,yn)`|
Representar gráficamente ecuaciones de un sistema con 3 incógnitas | `plotEqn3d(A,b)` de la librería `matlib` | `(*)` | `(**)` |
Calcular matriz escalonada reducida de una matriz | `echelon(AB, verbose = F, fractions = F)` | `-` | `rref(AB)` |
Resolver ecuaciones matriciales | `solve(A,B)` | `-` | `linsolve(A,B)` |

`(*)`
```{python, eval = F}
#Ejemplo 1
from mpl_toolkits.mplot3d import Axes3D

#Considerando la ecuación general de un plano Ax+By+Cz*D=0
point1  = np.array([0,0,9/2])
n1 = np.array([1,1,2])

point2  = np.array([0,0,-1/3])
n2 = np.array([2,4,-3])

point3  = np.array([0,0,0])
n3 = np.array([3,6,-5])

#Términos independientes
D1 = -9
D2 = -1
D3 = 0

# Creamos la matriz de coordenadas
X, Y = np.meshgrid(range(30), range(30))

# Calculamos z en función de x e y
z1 = (-n1[0]*X - n1[1]*Y - D1)*1./n1[2]
z2 = (-n2[0]*X - n2[1]*Y - D2)*1./n2[2]
z3 = (-n3[0]*X - n3[1]*Y - D3)*1./n3[2]

#Creamos y dibujamos el plot
plot3d = plt.figure().gca(projection='3d')
plot3d.plot_surface(X,Y,z1, color='red')
plot3d.plot_surface(X,Y,z2, color='cyan')
plot3d.plot_surface(X,Y,z3, color='yellow')
plt.show()
```

`(**)`
```{octave, eval = F}
%Ejemplo 1
%planos
[x,y] = meshgrid(0:0.1:3);
z = (9-x-y)/2;
hold on
mesh(x,y,z)
z = (2*x+4*y-1)/3;
mesh(x,y,z)
z = (3*x+6*y)/5;
mesh(x,y,z)
%Punto de interseccion
plot3(1,2,3,'ro','markersize',7,'markerfacecolor','r');
hold off
view(120,30)
```


## Tema 3


